#!/usr/bin/env python3

import logging
import logging.handlers
import re
import secrets
import sys
import time
import traceback
import warnings
from datetime import datetime, timedelta, timezone
from pathlib import Path
from enum import StrEnum, unique

import click

from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.utils import CryptographyDeprecationWarning

from ykman.device import list_all_devices
from ykman.piv import pivman_change_pin, pivman_set_mgm_key, sign_certificate_builder
from yubikit.core import TRANSPORT
from yubikit.core.smartcard import SmartCardConnection
from yubikit.management import ManagementSession, DeviceConfig, CAPABILITY
from yubikit.piv import (
    PivSession,
    SLOT,
    MANAGEMENT_KEY_TYPE,
    PIN_POLICY,
    TOUCH_POLICY,
    KEY_TYPE,
)


DEFAULT_PIN = "123456"
DEFAULT_PUK = "12345678"
DEFAULT_MANAGEMENT = bytes.fromhex("010203040506070801020304050607080102030405060708")

logger = logging.getLogger("pki")
warnings.filterwarnings(
    "ignore", category=CryptographyDeprecationWarning, message=".*TripleDES.*"
)


@unique
class YUBIKEY(StrEnum):
    ROOT = "Root X"
    INTERMEDIATE = "Intermediate"


class CustomFormatter(logging.Formatter):
    def formatException(self, exc_info):
        exc_type, exc_value, tb = exc_info
        script_dir = Path(__file__).parent

        # Find the frame from our code
        relevant_frame = None
        for frame in traceback.extract_tb(tb):
            frame_path = Path(frame.filename)
            try:
                frame_path.relative_to(script_dir)
                relevant_frame = frame
            except ValueError:
                continue

        if relevant_frame:
            return f" On line {relevant_frame.lineno}: {relevant_frame.line}"
        return super.formatException(self, exc_info)


def validate_pin(ctx, param, value):
    if not re.match(r"[0-9]{6,8}", value):
        raise click.BadParameter("PIN should be 6 to 8 numeric string")
    return value


def validate_puk(ctx, param, value):
    if not re.match(r"[a-zA-Z0-9]{6,8}", value):
        raise click.BadParameter("PUK should be 6 to 8 alphanumeric string")
    return value


def validate_management_key(ctx, param, val):
    try:
        if val == ".":
            val = secrets.token_bytes(32)
            logger.warning(f"Using random management key: {val.hex()}")
            return val
        if type(val) is str:
            val = bytes.fromhex(val)
        if len(val) == 32:
            return val
    except ValueError:
        pass
    raise click.BadParameter(
        "Management key must be exactly 32 (64 hexadecimal digits) long."
    )


def yubikey_one(yk: YUBIKEY):
    """Get exactly one Yubikey."""
    click.pause(f'Plug Yubikey "{yk}"...')
    devices = list(list_all_devices())
    for nb, di in enumerate(devices):
        device, info = di
        logger.info(f"{nb: >2}: {device.fingerprint}")
        logger.info(f"SN: {info.serial}")
        if len(devices) == 1:
            return device
    if len(devices) == 0:
        raise RuntimeError("No Yubikey found!")
    raise RuntimeError("Too many Yubikeys found!")


def click_pin(yk: str):
    return click.option(
        "--pin",
        prompt=f"PIN code for {yk}",
        help=f"PIN code for {yk}",
        hide_input=True,
        type=click.STRING,
        callback=validate_pin,
    )


def click_management_key(yk: str):
    return click.option(
        "--management-key",
        prompt=f"Management key for {yk}",
        help=f"Management key for {yk}",
        hide_input=True,
        type=click.UNPROCESSED,
        callback=validate_management_key,
    )


@click.group()
@click.option("--debug", is_flag=True, default=False)
def cli(debug: bool) -> None:
    """Simple offline PKI using Yubikeys as HSM.

    This program is a very barebone PKI for offline certificates. It requires at
    least three Yubikeys as HSM to store the root certificate (on "ROOT1" and
    "ROOT2", as a backup) and the intermediate certificate (on "INTERMEDIATE").

    The features are quite limited as it only provides root CA and intermediate
    CA creation, CRL generation for each of them, and certificate signing.
    """
    root = logging.getLogger("")
    root.setLevel(logging.INFO)
    logger.setLevel(debug and logging.DEBUG or logging.INFO)
    ch = logging.StreamHandler()
    ch.setFormatter(CustomFormatter("%(levelname)s[%(name)s] %(message)s"))
    root.addHandler(ch)


@cli.group("yubikey")
def yubikey() -> None:
    """Yubikey management."""


@yubikey.command("info")
def yubikey_info() -> None:
    """Display information about the inserted Yubikeys."""
    for nb, di in enumerate(list_all_devices()):
        device, info = di
        logger.info(f"{nb: >2}: {device.fingerprint}")
        logger.info(f"SN: {info.serial}")
        with device.open_connection(SmartCardConnection) as conn:
            piv = PivSession(conn)
            data = piv.get_slot_metadata(SLOT.SIGNATURE)
            logger.info(f"Slot {SLOT.SIGNATURE}:")
            logger.info(f"  Private key type: {data.key_type}")
            cert = piv.get_certificate(SLOT.SIGNATURE)
            pkey = data.public_key
            algorithm = pkey.curve.name
            issuer = cert.issuer.rfc4514_string()
            subject = cert.subject.rfc4514_string()
            serial = cert.serial_number
            not_before = cert.not_valid_before_utc.isoformat()
            not_after = cert.not_valid_after_utc.isoformat()
            pem_data = cert.public_bytes(encoding=serialization.Encoding.PEM).decode(
                "utf-8"
            )
            logger.info("  Public key: ")
            logger.info(f"    Algorithm:  {algorithm}")
            logger.info(f"    Issuer:     {issuer}")
            logger.info(f"    Subject:    {subject}")
            logger.info(f"    Serial:     {serial}")
            logger.info(f"    Not before: {not_before}")
            logger.info(f"    Not after:  {not_after}")
            logger.info(f"    PEM:\n{pem_data}")


@yubikey.command("reset")
@click.confirmation_option(
    prompt="This will reset the connected Yubikey. Are you sure?"
)
@click.option(
    "--new-pin",
    prompt="New PIN code",
    help="PIN code",
    hide_input=True,
    confirmation_prompt=True,
    type=click.STRING,
    callback=validate_pin,
)
@click.option(
    "--new-puk",
    prompt="New PUK code",
    help="PUK code",
    hide_input=True,
    confirmation_prompt=True,
    type=click.STRING,
    callback=validate_puk,
)
@click.option(
    "--new-management-key",
    prompt="New management key ('.' to generate a random one)",
    help="Management key",
    hide_input=True,
    type=click.UNPROCESSED,
    callback=validate_management_key,
)
def yubikey_reset(new_pin: str, new_puk: str, new_management_key: bytes) -> None:
    """Reset the inserted Yubikeys."""
    found = False
    for nb, di in enumerate(list_all_devices()):
        found = True
        device, info = di
        logger.info(f"{nb: >2}: {device.fingerprint}")
        logger.info(f"SN: {info.serial}")
        with device.open_connection(SmartCardConnection) as conn:
            mgt = ManagementSession(conn)
            logger.debug("Only enable PIV application")
            config = DeviceConfig({}, None, None, None)
            config.enabled_capabilities = {
                TRANSPORT.NFC: CAPABILITY(0),
                TRANSPORT.USB: CAPABILITY.PIV,
            }
            mgt.write_device_config(config, True, None, None)
        logger.debug("Wait a bit for Yubikey to reboot")
        for retry in reversed(range(5)):
            time.sleep(1)
            for _, di2 in enumerate(list_all_devices()):
                device2, info2 = di2
                if info2.serial == info.serial:
                    device = device2
                    break
            else:
                if retry > 0:
                    continue
                raise RuntimeError("no Yubikey found")
            break
        with device.open_connection(SmartCardConnection) as conn:
            piv = PivSession(conn)
            logger.debug("Reset PIV application")
            piv.reset()
            logger.debug("Set management key")
            piv.authenticate(DEFAULT_MANAGEMENT)
            pivman_set_mgm_key(piv, new_management_key, MANAGEMENT_KEY_TYPE.AES256)
            logger.debug("Set PIN and PUK code")
            piv.change_puk(DEFAULT_PUK, new_puk)
            pivman_change_pin(piv, DEFAULT_PIN, new_pin)
        logger.info("Yubikey reset successful!")
    if not found:
        raise RuntimeError("No Yubikey found!")


@cli.group("certificate")
def certificate() -> None:
    """Certificate management."""


@certificate.command("root")
@click_management_key(YUBIKEY.ROOT)
@click.option("--cn", default="Root CA", help="Common name", type=click.STRING)
@click.option(
    "--org", prompt="Organization name", help="Organization name", type=click.STRING
)
@click.option(
    "--days",
    default=365 * 20,
    help="Root certificate validity in days",
    type=click.IntRange(min=1),
)
def certificate_root(management_key: bytes, cn: str, org: str, days: int) -> None:
    """Initialize a new root certificate."""
    logger.debug("Generate a new private key")
    private_key = ec.generate_private_key(ec.SECP384R1())
    subject = issuer = x509.Name(
        [
            x509.NameAttribute(NameOID.COMMON_NAME, cn),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, org),
        ]
    )
    logger.debug("Generate a new certificate")
    cert = (
        (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(private_key.public_key())
            .serial_number(1)
            .not_valid_before(datetime.now(timezone.utc))
            .not_valid_after(datetime.now(timezone.utc) + timedelta(days=days))
        )
        .add_extension(x509.BasicConstraints(ca=True, path_length=None), critical=True)
        .add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=True,
                crl_sign=True,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )
        .sign(private_key, hashes.SHA384())
    )
    while True:
        with yubikey_one(YUBIKEY.ROOT).open_connection(SmartCardConnection) as conn:
            piv = PivSession(conn)
            piv.authenticate(management_key)
            piv.put_certificate(SLOT.SIGNATURE, cert, compress=True)
            piv.put_key(
                SLOT.SIGNATURE, private_key, PIN_POLICY.ONCE, TOUCH_POLICY.NEVER
            )
        if not click.confirm("Copy root certificate to another Yubikey?"):
            break


@certificate.command("intermediate")
@click_management_key(YUBIKEY.INTERMEDIATE)
@click_pin(YUBIKEY.ROOT)
@click.option("--cn", default="Intermediate CA", help="Common name", type=click.STRING)
@click.option("--org", help="Organization name", type=click.STRING)
@click.option(
    "--days",
    default=365 * 4,
    help="Intermediate certificate validity in days",
    type=click.IntRange(min=1),
)
def certificate_intermediate(
    management_key: bytes, pin: str, cn: str, org: str, days: int
) -> None:
    """Initialize a new intermediate certificate."""
    with yubikey_one(YUBIKEY.INTERMEDIATE).open_connection(SmartCardConnection) as conn:
        logger.debug("Generate private key for intermediate certificate")
        piv = PivSession(conn)
        piv.authenticate(management_key)
        public_key = piv.generate_key(
            SLOT.SIGNATURE, KEY_TYPE.ECCP384, PIN_POLICY.ONCE, TOUCH_POLICY.NEVER
        )
    with yubikey_one(YUBIKEY.ROOT).open_connection(SmartCardConnection) as conn:
        logger.debug("Create intermediate certificate")
        piv = PivSession(conn)
        root = piv.get_certificate(SLOT.SIGNATURE)
        if root.issuer.rfc4514_string() != root.subject.rfc4514_string():
            raise RuntimeError("The inserted key does not look like a root Yubikey!")
        issuer = root.subject
        if not org:
            org = str(
                root.subject.get_attributes_for_oid(NameOID.ORGANIZATION_NAME)[0].value
            )
            logger.info(f'Using "{org}" for organization name')
        subject = x509.Name(
            [
                x509.NameAttribute(NameOID.COMMON_NAME, cn),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, org),
            ]
        )
        cert = (
            (
                x509.CertificateBuilder()
                .subject_name(subject)
                .issuer_name(issuer)
                .public_key(public_key)
                .serial_number(x509.random_serial_number())
                .not_valid_before(datetime.now(timezone.utc))
                .not_valid_after(datetime.now(timezone.utc) + timedelta(days=days))
            )
            .add_extension(
                x509.BasicConstraints(ca=True, path_length=None), critical=True
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    content_commitment=False,
                    key_encipherment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    key_cert_sign=True,
                    crl_sign=True,
                    encipher_only=False,
                    decipher_only=False,
                ),
                critical=True,
            )
        )
        piv.verify_pin(pin)
        signed_cert = sign_certificate_builder(
            piv,
            slot=SLOT.SIGNATURE,
            key_type=KEY_TYPE.ECCP384,
            builder=cert,
            hash_algorithm=hashes.SHA384,
        )
    with yubikey_one(YUBIKEY.INTERMEDIATE).open_connection(SmartCardConnection) as conn:
        logger.debug("Store certificate")
        piv = PivSession(conn)
        piv.authenticate(management_key)
        piv.put_certificate(SLOT.SIGNATURE, signed_cert, compress=True)


if __name__ == "__main__":
    try:
        cli(prog_name="pki")
    except Exception as e:
        logger.exception("%s", e)
        sys.exit(0)
