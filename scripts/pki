#!/usr/bin/env python3

import logging
import logging.handlers
import re
import secrets
import sys
import time
import traceback
import typing
import warnings
from datetime import datetime, timedelta, timezone
from enum import StrEnum, unique
from types import SimpleNamespace

import click
from cryptography.utils import CryptographyDeprecationWarning


DEFAULT_PIN = "123456"
DEFAULT_PUK = "12345678"
DEFAULT_MANAGEMENT = bytes.fromhex("010203040506070801020304050607080102030405060708")

logger = logging.getLogger("pki")
warnings.filterwarnings(
    "ignore", category=CryptographyDeprecationWarning, message=".*TripleDES.*"
)


@unique
class YUBIKEY(StrEnum):
    ROOT = "Root X"
    INTERMEDIATE = "Intermediate"


class CustomFormatter(logging.Formatter):
    def formatException(self, exc_info):
        exc_type, exc_value, tb = exc_info

        # Find the frame from our code
        relevant_frame = None
        for frame in traceback.extract_tb(tb):
            if frame.filename == __file__:
                relevant_frame = frame
                break
        else:
            return super().formatException(self, exc_info)

        return f" On line {relevant_frame.lineno}: {relevant_frame.line}"


class M:
    """Lazy loading of some modules."""

    @property
    def yk(self) -> SimpleNamespace:
        from ykman.device import list_all_devices
        from ykman.piv import (
            pivman_change_pin,
            pivman_set_mgm_key,
            sign_certificate_builder,
        )
        from yubikit.core import TRANSPORT
        from yubikit.core.smartcard import SmartCardConnection
        from yubikit.management import ManagementSession, DeviceConfig, CAPABILITY
        from yubikit.piv import (
            PivSession,
            SLOT,
            MANAGEMENT_KEY_TYPE,
            PIN_POLICY,
            TOUCH_POLICY,
            KEY_TYPE,
        )

        return SimpleNamespace(**locals())

    @property
    def cryptography(self) -> SimpleNamespace:
        from cryptography import x509
        from cryptography.x509.oid import NameOID
        from cryptography.hazmat.primitives import hashes, serialization
        from cryptography.hazmat.primitives.asymmetric import ec, rsa, padding

        return SimpleNamespace(**locals())


m = M()


def validate_pin(ctx, param, value):
    if not re.match(r"[0-9]{6,8}", value):
        raise click.BadParameter("PIN should be 6 to 8 numeric string")
    return value


def validate_puk(ctx, param, value):
    if not re.match(r"[a-zA-Z0-9]{6,8}", value):
        raise click.BadParameter("PUK should be 6 to 8 alphanumeric string")
    return value


def validate_management_key(ctx, param, val):
    try:
        if val == ".":
            val = secrets.token_bytes(32)
            logger.warning(f"Using random management key: {val.hex()}")
            return val
        if type(val) is str:
            val = bytes.fromhex(val)
        if len(val) == 32:
            return val
    except ValueError:
        pass
    raise click.BadParameter(
        "Management key must be exactly 32 (64 hexadecimal digits) long."
    )


def yubikey_one(yk: YUBIKEY):
    """Get exactly one Yubikey."""
    click.pause(f'Plug Yubikey "{yk}"...')
    devices = list(m.yk.list_all_devices())
    for nb, di in enumerate(devices):
        device, info = di
        logger.info(f"{nb: >2}: {device.fingerprint}")
        logger.info(f"SN: {info.serial}")
        if len(devices) == 1:
            return device
    if len(devices) == 0:
        raise RuntimeError("No Yubikey found!")
    raise RuntimeError("Too many Yubikeys found!")


def click_pin(yk: str):
    return click.option(
        "--pin",
        prompt=f"PIN code for {yk}",
        help=f"PIN code for {yk}",
        hide_input=True,
        type=click.STRING,
        callback=validate_pin,
    )


def click_management_key(yk: str):
    return click.option(
        "--management-key",
        prompt=f"Management key for {yk}",
        help=f"Management key for {yk}",
        hide_input=True,
        type=click.UNPROCESSED,
        callback=validate_management_key,
    )


@click.group()
@click.option("--debug", is_flag=True, default=False)
def cli(debug: bool) -> None:
    """Simple offline PKI using Yubikeys as HSM.

    This program is a very barebone PKI for offline certificates. It requires at
    least three Yubikeys as HSM to store the root certificate (on "ROOT1" and
    "ROOT2", as a backup) and the intermediate certificate (on "INTERMEDIATE").

    The features are quite limited as it only provides root CA and intermediate
    CA creation, CRL gene ration for each of them, and certificate signing.
    """
    root = logging.getLogger("")
    root.setLevel(logging.INFO)
    logger.setLevel(debug and logging.DEBUG or logging.INFO)
    ch = logging.StreamHandler()
    ch.setFormatter(CustomFormatter("%(levelname)s[%(name)s] %(message)s"))
    root.addHandler(ch)


@cli.group("yubikey")
def yubikey() -> None:
    """Yubikey management."""


@yubikey.command("info")
def yubikey_info() -> None:
    """Display information about the inserted Yubikeys."""
    for nb, di in enumerate(m.yk.list_all_devices()):
        device, info = di
        logger.info(f"{nb: >2}: {device.fingerprint}")
        logger.info(f"SN: {info.serial}")
        with device.open_connection(m.yk.SmartCardConnection) as conn:
            piv = m.yk.PivSession(conn)
            data = piv.get_slot_metadata(m.yk.SLOT.SIGNATURE)
            logger.info(f"Slot {m.yk.SLOT.SIGNATURE}:")
            logger.info(f"  Private key type: {data.key_type}")
            cert = piv.get_certificate(m.yk.SLOT.SIGNATURE)
            pkey = data.public_key
            algorithm = pkey.curve.name
            issuer = cert.issuer.rfc4514_string()
            subject = cert.subject.rfc4514_string()
            serial = cert.serial_number
            not_before = cert.not_valid_before_utc.isoformat()
            not_after = cert.not_valid_after_utc.isoformat()
            pem_data = cert.public_bytes(
                encoding=m.cryptography.serialization.Encoding.PEM
            ).decode("utf-8")
            logger.info("  Public key: ")
            logger.info(f"    Algorithm:  {algorithm}")
            logger.info(f"    Issuer:     {issuer}")
            logger.info(f"    Subject:    {subject}")
            logger.info(f"    Serial:     {serial}")
            logger.info(f"    Not before: {not_before}")
            logger.info(f"    Not after:  {not_after}")
            logger.info(f"    PEM:\n{pem_data}")


@yubikey.command("reset")
@click.confirmation_option(
    prompt="This will reset the connected Yubikey. Are you sure?"
)
@click.option(
    "--new-pin",
    prompt="New PIN code",
    help="PIN code",
    hide_input=True,
    confirmation_prompt=True,
    type=click.STRING,
    callback=validate_pin,
)
@click.option(
    "--new-puk",
    prompt="New PUK code",
    help="PUK code",
    hide_input=True,
    confirmation_prompt=True,
    type=click.STRING,
    callback=validate_puk,
)
@click.option(
    "--new-management-key",
    prompt="New management key ('.' to generate a random one)",
    help="Management key",
    hide_input=True,
    type=click.UNPROCESSED,
    callback=validate_management_key,
)
def yubikey_reset(new_pin: str, new_puk: str, new_management_key: bytes) -> None:
    """Reset the inserted Yubikeys."""
    found = False
    for nb, di in enumerate(m.yk.list_all_devices()):
        found = True
        device, info = di
        logger.info(f"{nb: >2}: {device.fingerprint}")
        logger.info(f"SN: {info.serial}")
        with device.open_connection(m.yk.SmartCardConnection) as conn:
            mgt = m.yk.ManagementSession(conn)
            logger.debug("Only enable PIV application")
            config = m.yk.DeviceConfig({}, None, None, None)
            config.enabled_capabilities = {
                m.yk.TRANSPORT.NFC: m.yk.CAPABILITY(0),
                m.yk.TRANSPORT.USB: m.yk.CAPABILITY.PIV,
            }
            mgt.write_device_config(config, True, None, None)
        logger.debug("Wait a bit for Yubikey to reboot")
        for retry in reversed(range(5)):
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", message="Failed opening device")
                time.sleep(1)
                for _, di2 in enumerate(m.yk.list_all_devices()):
                    device2, info2 = di2
                    if info2.serial == info.serial:
                        device = device2
                        break
                else:
                    if retry > 0:
                        continue
                    raise RuntimeError("no Yubikey found")
                break
        with device.open_connection(m.yk.SmartCardConnection) as conn:
            piv = m.yk.PivSession(conn)
            logger.debug("Reset PIV application")
            piv.reset()
            logger.debug("Set management key")
            piv.authenticate(DEFAULT_MANAGEMENT)
            m.yk.pivman_set_mgm_key(
                piv, new_management_key, m.yk.MANAGEMENT_KEY_TYPE.AES256
            )
            logger.debug("Set PIN and PUK code")
            piv.change_puk(DEFAULT_PUK, new_puk)
            m.yk.pivman_change_pin(piv, DEFAULT_PIN, new_pin)
        logger.info("Yubikey reset successful!")
    if not found:
        raise RuntimeError("No Yubikey found!")


@cli.group("certificate")
def certificate() -> None:
    """Certificate management."""


@certificate.command("root")
@click_management_key(YUBIKEY.ROOT)
@click.option(
    "--subject-name", default="CN=Root CA", help="Subject name", type=click.STRING
)
@click.option(
    "--days",
    default=365 * 20,
    help="Root certificate validity in days",
    type=click.IntRange(min=1),
)
def certificate_root(management_key: bytes, subject_name: str, days: int) -> None:
    """Initialize a new root certificate."""
    logger.debug("Generate a new private key")
    private_key = m.cryptography.ec.generate_private_key(m.cryptography.ec.SECP384R1())
    subject = m.cryptography.x509.Name.from_rfc4514_string(subject_name)
    logger.debug("Generate a new certificate")
    cert = (
        (
            m.cryptography.x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(subject)
            .public_key(private_key.public_key())
            .serial_number(1)
            .not_valid_before(datetime.now(timezone.utc))
            .not_valid_after(datetime.now(timezone.utc) + timedelta(days=days))
        )
        .add_extension(
            m.cryptography.x509.BasicConstraints(ca=True, path_length=None),
            critical=True,
        )
        .add_extension(
            m.cryptography.x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=True,
                crl_sign=True,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )
        .sign(private_key, m.cryptography.hashes.SHA384())
    )
    while True:
        with yubikey_one(YUBIKEY.ROOT).open_connection(
            m.yk.SmartCardConnection
        ) as conn:
            piv = m.yk.PivSession(conn)
            piv.authenticate(management_key)
            piv.put_certificate(m.yk.SLOT.SIGNATURE, cert, compress=True)
            piv.put_key(
                m.yk.SLOT.SIGNATURE,
                private_key,
                m.yk.PIN_POLICY.ONCE,
                m.yk.TOUCH_POLICY.NEVER,
            )
        if not click.confirm("Copy root certificate to another Yubikey?"):
            break


@certificate.command("intermediate")
@click_management_key(YUBIKEY.INTERMEDIATE)
@click_pin(YUBIKEY.ROOT)
@click.option(
    "--subject-name",
    default="CN=Intermediate CA",
    help="Subject name",
    type=click.STRING,
)
@click.option(
    "--days",
    default=365 * 4,
    help="Intermediate certificate validity in days",
    type=click.IntRange(min=1),
)
def certificate_intermediate(
    management_key: bytes, pin: str, subject_name: str, days: int
) -> None:
    """Initialize a new intermediate certificate.

    If the subject name is missing an attribute compared to the root certificate,
    they are copied over.
    """
    with yubikey_one(YUBIKEY.INTERMEDIATE).open_connection(
        m.yk.SmartCardConnection
    ) as conn:
        logger.debug("Generate private key for intermediate certificate")
        piv = m.yk.PivSession(conn)
        piv.authenticate(management_key)
        public_key = piv.generate_key(
            m.yk.SLOT.SIGNATURE,
            m.yk.KEY_TYPE.ECCP384,
            m.yk.PIN_POLICY.ONCE,
            m.yk.TOUCH_POLICY.NEVER,
        )
    with yubikey_one(YUBIKEY.ROOT).open_connection(m.yk.SmartCardConnection) as conn:
        logger.debug("Create intermediate certificate")
        piv = m.yk.PivSession(conn)
        root = piv.get_certificate(m.yk.SLOT.SIGNATURE)
        if root.issuer.rfc4514_string() != root.subject.rfc4514_string():
            raise RuntimeError("The inserted key does not look like a root Yubikey!")
        issuer = root.subject
        subject = m.cryptography.x509.Name.from_rfc4514_string(subject_name)
        missing = [
            attribute
            for attribute in issuer
            if attribute.oid not in [attr.oid for attr in subject]
        ]
        subject = m.cryptography.x509.Name(missing + [attr for attr in subject])
        logger.debug(f"Subject name is {subject.rfc4514_string()}")
        cert = (
            (
                m.cryptography.x509.CertificateBuilder()
                .subject_name(subject)
                .issuer_name(issuer)
                .public_key(public_key)
                .serial_number(m.cryptography.x509.random_serial_number())
                .not_valid_before(datetime.now(timezone.utc))
                .not_valid_after(datetime.now(timezone.utc) + timedelta(days=days))
            )
            .add_extension(
                m.cryptography.x509.BasicConstraints(ca=True, path_length=None),
                critical=True,
            )
            .add_extension(
                m.cryptography.x509.KeyUsage(
                    digital_signature=True,
                    content_commitment=False,
                    key_encipherment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    key_cert_sign=True,
                    crl_sign=True,
                    encipher_only=False,
                    decipher_only=False,
                ),
                critical=True,
            )
        )
        piv.verify_pin(pin)
        signed_cert = m.yk.sign_certificate_builder(
            piv,
            slot=m.yk.SLOT.SIGNATURE,
            key_type=m.yk.KEY_TYPE.ECCP384,
            builder=cert,
            hash_algorithm=m.cryptography.hashes.SHA384,
        )
    with yubikey_one(YUBIKEY.INTERMEDIATE).open_connection(
        m.yk.SmartCardConnection
    ) as conn:
        logger.debug("Store certificate")
        piv = m.yk.PivSession(conn)
        piv.authenticate(management_key)
        piv.put_certificate(m.yk.SLOT.SIGNATURE, signed_cert, compress=True)


@certificate.command("sign")
@click_pin(YUBIKEY.INTERMEDIATE)
@click.option(
    "--subject-name",
    help="Subject name",
    type=click.STRING,
)
@click.option(
    "--days",
    default=365,
    help="Certificate validity in days",
    type=click.IntRange(min=1),
)
@click.option(
    "--csr-file", help="CSR file to sign", type=click.File("rt"), default=sys.stdin
)
@click.option(
    "--out-file",
    help="Output file for signed certificate",
    type=click.File("wt"),
    default=sys.stdout,
)
def certificate_sign(
    pin: str,
    subject_name: str,
    days: int,
    csr_file: typing.TextIO,
    out_file: typing.TextIO,
) -> None:
    """Sign a certificate request with the intermediate certificate.

    If no subject name is provided, the one from the CSR is used.
    """
    logger.debug("load CSR file and check signature")
    csr = m.cryptography.x509.load_pem_x509_csr(csr_file.read().encode("ascii"))
    public_key = csr.public_key()
    if (
        isinstance(public_key, m.cryptography.rsa.RSAPublicKey)
        and csr.signature_hash_algorithm is not None
    ):
        public_key.verify(
            csr.signature,
            csr.tbs_certrequest_bytes,
            m.cryptography.padding.PKCS1v15(),
            csr.signature_hash_algorithm,
        )
    elif isinstance(public_key, m.cryptography.ec.EllipticCurvePublicKey):
        public_key.verify(
            csr.signature,
            csr.tbs_certrequest_bytes,
            m.cryptography.ec.ECDSA(csr.signature_hash_algorithm),
        )
    else:
        raise ValueError(f"unsupported public key {public_key}")

    with yubikey_one(YUBIKEY.INTERMEDIATE).open_connection(
        m.yk.SmartCardConnection
    ) as conn:
        piv = m.yk.PivSession(conn)
        intermediate = piv.get_certificate(m.yk.SLOT.SIGNATURE)
        if (
            intermediate.issuer.rfc4514_string()
            == intermediate.subject.rfc4514_string()
        ):
            raise RuntimeError(
                "The inserted key does not look like an intermediate Yubikey!"
            )

        logger.debug("build certificate")
        issuer = intermediate.subject
        if not subject_name:
            subject = csr.subject
        else:
            subject = m.cryptography.x509.Name.from_rfc4514_string(subject_name)
            missing = [
                attribute
                for attribute in issuer
                if attribute.oid not in [attr.oid for attr in subject]
            ]
            subject = m.cryptography.x509.Name(missing + [attr for attr in subject])
        logger.info(f"Subject name is {subject.rfc4514_string()}")
        cert = (
            m.cryptography.x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(public_key)
            .serial_number(m.cryptography.x509.random_serial_number())
            .not_valid_before(datetime.now(timezone.utc))
            .not_valid_after(datetime.now(timezone.utc) + timedelta(days=days))
        )
        for extension in csr.extensions:
            logger.debug(f"Add extension {extension.value}")
            cert = cert.add_extension(extension.value, extension.critical)
        # TODO: it would be useful to display the certificate, but there seems
        # to be no method for that.
        click.confirm("Sign this certificate?", abort=True)

        piv.verify_pin(pin)
        signed_cert = m.yk.sign_certificate_builder(
            piv,
            slot=m.yk.SLOT.SIGNATURE,
            key_type=m.yk.KEY_TYPE.ECCP384,
            builder=cert,
            hash_algorithm=m.cryptography.hashes.SHA384,
        )
        out_file.write(
            signed_cert.public_bytes(
                encoding=m.cryptography.serialization.Encoding.PEM
            ).decode("ascii")
        )


if __name__ == "__main__":
    try:
        cli(prog_name="pki")
    except Exception as e:
        logger.exception("%s", e)
        sys.exit(0)
